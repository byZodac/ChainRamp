import { SendTransactionPayload, WalletApi } from '@concordium/browser-wallet-api-helpers';
import { AccountTransactionSignature, AccountTransactionType, CredentialStatements, VerifiablePresentation } from '@concordium/web-sdk';
import { SignableMessage, TypedSmartContractParameters, WalletConnection, WalletConnectionDelegate, WalletConnector } from './WalletConnection';
/**
 * Implementation of both {@link WalletConnector} and {@link WalletConnection} for the Concordium Browser Wallet.
 * Implementing both interfaces in the same class is a good fit for this protocol
 * as all interaction with the wallet's API happens through a single stateful client.
 */
export declare class BrowserWalletConnector implements WalletConnector, WalletConnection {
    readonly client: WalletApi;
    readonly delegate: WalletConnectionDelegate;
    isConnected: boolean;
    /**
     * Construct a new instance.
     *
     * Use {@link create} to have the API client initialized automatically.
     *
     * The constructor sets up event handling and appropriate forwarding to the provided delegate.
     *
     * @param client The underlying API client.
     * @param delegate The object to receive events emitted by the client.
     */
    constructor(client: WalletApi, delegate: WalletConnectionDelegate);
    static create(delegate: WalletConnectionDelegate): Promise<BrowserWalletConnector>;
    connect(): Promise<this>;
    getConnections(): this[];
    getConnector(): this;
    ping(): Promise<undefined>;
    /**
     * @return The account that the wallet currently associates with this connection.
     */
    getConnectedAccount(): Promise<string | undefined>;
    /**
     * Returns the transport object of the gRPC client that the Browser Wallet uses to perform requests
     * against some Concordium Node connected to network/chain that the connected account lives on.
     * The client implements version 2 of the Node API.
     *
     * This method is included because it's part of the Browser Wallet API.
     * It should be used with care as it's hard to guarantee that it actually connects to the expected network.
     * The recommended alternative is to construct your own client using {@link Network.grpcOpts} which is
     * independent of any connection.
     *
     * @return The Browser Wallet's internal gRPC client.
     * @throws If the installed version of the Browser Wallet doesn't support the method.
     */
    getGrpcTransport(): import("@protobuf-ts/runtime-rpc").RpcTransport;
    /**
     * Deregister event handlers on the API client and notify the delegate.
     * As there's no way to actually disconnect the Browser Wallet, this is all that we can reasonably do.
     * The client object will remain in the browser's global state.
     */
    disconnect(): Promise<void>;
    signAndSendTransaction(accountAddress: string, type: AccountTransactionType, payload: SendTransactionPayload, typedParams?: TypedSmartContractParameters): Promise<string>;
    signMessage(accountAddress: string, msg: SignableMessage): Promise<AccountTransactionSignature>;
    requestVerifiablePresentation(challenge: string, credentialStatements: CredentialStatements): Promise<VerifiablePresentation>;
}
//# sourceMappingURL=BrowserWallet.d.ts.map