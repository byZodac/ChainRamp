var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { SchemaType, detectConcordiumProvider, } from '@concordium/browser-wallet-api-helpers';
import { AccountTransactionType, } from '@concordium/web-sdk';
import { UnreachableCaseError } from './error';
const BROWSER_WALLET_DETECT_TIMEOUT = 2000;
/**
 * Implementation of both {@link WalletConnector} and {@link WalletConnection} for the Concordium Browser Wallet.
 * Implementing both interfaces in the same class is a good fit for this protocol
 * as all interaction with the wallet's API happens through a single stateful client.
 */
export class BrowserWalletConnector {
    /**
     * Construct a new instance.
     *
     * Use {@link create} to have the API client initialized automatically.
     *
     * The constructor sets up event handling and appropriate forwarding to the provided delegate.
     *
     * @param client The underlying API client.
     * @param delegate The object to receive events emitted by the client.
     */
    constructor(client, delegate) {
        this.isConnected = false;
        this.client = client;
        this.delegate = delegate;
        this.client.on('chainChanged', (c) => delegate.onChainChanged(this, c));
        this.client.on('accountChanged', (a) => delegate.onAccountChanged(this, a));
        this.client.on('accountDisconnected', () => this.client
            .getMostRecentlySelectedAccount()
            .then((a) => delegate.onAccountChanged(this, a))
            .catch(console.error));
    }
    static create(delegate) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const client = yield detectConcordiumProvider(BROWSER_WALLET_DETECT_TIMEOUT);
                return new BrowserWalletConnector(client, delegate);
            }
            catch (e) {
                // Provider detector throws 'undefined' when rejecting!
                throw new Error('Browser Wallet extension not detected');
            }
        });
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const account = yield this.client.connect();
            if (!account) {
                throw new Error('Browser Wallet connection failed');
            }
            this.isConnected = true;
            this.delegate.onConnected(this, account);
            return this;
        });
    }
    getConnections() {
        return this.isConnected ? [this] : [];
    }
    getConnector() {
        return this;
    }
    ping() {
        return __awaiter(this, void 0, void 0, function* () {
            return undefined;
        });
    }
    /**
     * @return The account that the wallet currently associates with this connection.
     */
    getConnectedAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.getMostRecentlySelectedAccount();
        });
    }
    /**
     * Returns the transport object of the gRPC client that the Browser Wallet uses to perform requests
     * against some Concordium Node connected to network/chain that the connected account lives on.
     * The client implements version 2 of the Node API.
     *
     * This method is included because it's part of the Browser Wallet API.
     * It should be used with care as it's hard to guarantee that it actually connects to the expected network.
     * The recommended alternative is to construct your own client using {@link Network.grpcOpts} which is
     * independent of any connection.
     *
     * @return The Browser Wallet's internal gRPC client.
     * @throws If the installed version of the Browser Wallet doesn't support the method.
     */
    getGrpcTransport() {
        return this.client.grpcTransport;
    }
    /**
     * Deregister event handlers on the API client and notify the delegate.
     * As there's no way to actually disconnect the Browser Wallet, this is all that we can reasonably do.
     * The client object will remain in the browser's global state.
     */
    disconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            // The connection itself cannot actually be disconnected by the dApp as
            // only the wallet can initiate disconnecting individual accounts.
            // This "disconnect" only ensures that we stop interacting with the client
            // (which stays in the browser window's global state)
            // such that it doesn't interfere with a future reconnection.
            this.isConnected = false;
            this.client.removeAllListeners();
            this.delegate.onDisconnected(this);
        });
    }
    signAndSendTransaction(accountAddress, type, payload, typedParams) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((type === AccountTransactionType.InitContract || type === AccountTransactionType.Update) && typedParams) {
                const { parameters, schema } = typedParams;
                switch (schema.type) {
                    case 'ModuleSchema':
                        return this.client.sendTransaction(accountAddress, type, // wallet API types enforce strict coupling of transaction types and corresponding payloads.
                        payload, // wallet API types enforce strict coupling of transaction types and corresponding payloads.
                        parameters, {
                            type: SchemaType.Module,
                            value: schema.value.toString('base64'),
                        }, schema.version);
                    case 'TypeSchema':
                        return this.client.sendTransaction(accountAddress, type, payload, parameters, {
                            type: SchemaType.Parameter,
                            value: schema.value.toString('base64'),
                        });
                    default:
                        throw new UnreachableCaseError('schema', schema);
                }
            }
            if (typedParams) {
                throw new Error(`'typedParams' must not be provided for transaction of type '${type}'`);
            }
            return this.client.sendTransaction(accountAddress, type, payload); // wallet API types enforce strict coupling of transaction types and corresponding payloads.
        });
    }
    signMessage(accountAddress, msg) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (msg.type) {
                case 'StringMessage':
                    return this.client.signMessage(accountAddress, msg.value);
                case 'BinaryMessage':
                    return this.client.signMessage(accountAddress, {
                        schema: msg.schema.value.toString('base64'),
                        data: msg.value.toString('hex'),
                    });
                default:
                    throw new UnreachableCaseError('message', msg);
            }
        });
    }
    requestVerifiablePresentation(challenge, credentialStatements) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client.requestVerifiablePresentation(challenge, credentialStatements);
        });
    }
}
//# sourceMappingURL=BrowserWallet.js.map